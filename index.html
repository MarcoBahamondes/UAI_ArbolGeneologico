<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Online Python Compiler</title>
    <link href="data/img/favicon.ico" rel="icon" type="image/x-icon" />
    <script src="data/js/ace-builds/src-noconflict/ace.js" type="text/javascript"></script>
    <script src="data/js/ace-builds/src-noconflict/ext-language_tools.js" type="text/javascript"></script>
    <script src="data/js/skulpt/skulpt.js" type="text/javascript"></script>
    <script src="data/js/skulpt/skulpt-stdlib.js" type="text/javascript"></script>
    <link href="data/css/style.css" rel="stylesheet">
    <link href="data/fonts/fontawesome-free-6.1.1-web/css/fontawesome.min.css" rel="stylesheet">
    <link href="data/fonts/fontawesome-free-6.1.1-web/css/solid.min.css" rel="stylesheet">
    <link href="data/fonts/fontawesome-free-6.1.1-web/css/brands.min.css" rel="stylesheet">

</head>

<body>
    <div id="wrapper">
        <div class="topnav" id="myTopnav">
            <a onclick="main()">Run</a>
            <input type="file" />
            <a onclick="document.querySelector('input').click()">Open</a>
            <a onclick="toggleConsole()">Console</a>
            <a onclick="saveCode()">Save</a>
            <a onclick="downloadCode()">Download</a>
            <a onclick="shareCode()">Share</a>
            <a onclick="kbShortcuts()">Keyboard</a>
            <a onclick="aceSettings()">Settings</a>
            <a id="github" href="https://github.com/MarcoBahamondes/UAI_ArbolGeneologico" target="_blank"><i
                    class="fa-brands fa-github"></i></a>
            <a href="javascript:void(0);" class="icon" onclick="resPanel()">
                <i class="fa-solid fa-bars"></i>
            </a>
        </div>
        <div id="editor"><pre>
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import random
import time
from collections import deque
from typing import List, Optional, Tuple, Set
import uuid

class Person:
    """Representa una persona en el √°rbol geneal√≥gico"""
    
    def __init__(self, name: str, age: int, gender: str, level: int):
        self.id = str(uuid.uuid4())[:8]
        self.name = name
        self.age = age
        self.gender = gender
        self.level = level
        self.children: List['Person'] = []
        self.parent: Optional['Person'] = None
    
    def add_child(self, child: 'Person'):
        """A√±ade un hijo a esta persona"""
        child.parent = self
        self.children.append(child)
    
    def __str__(self):
        return f"{self.name} ({self.age} a√±os, {self.gender}, Nivel {self.level})"

class SearchResult:
    """Resultado de una b√∫squeda en el √°rbol"""
    
    def __init__(self, person: Optional[Person], found: bool, visited_nodes: int, 
                 execution_time: float, visited_order: List[Person]):
        self.person = person
        self.found = found
        self.visited_nodes = visited_nodes
        self.execution_time = execution_time
        self.visited_order = visited_order

class PersonGenerator:
    """Generador de personas aleatorias"""
    
    MALE_NAMES = [
        'Alexander', 'Benjamin', 'Carlos', 'David', 'Eduardo', 'Fernando', 'Gabriel', 'H√©ctor',
        'Ignacio', 'Javier', 'Lorenzo', 'Manuel', 'Nicol√°s', '√ìscar', 'Pablo', 'Rafael',
        'Sebasti√°n', 'Tom√°s', 'Vicente', 'William'
    ]
    
    FEMALE_NAMES = [
        'Alejandra', 'Beatriz', 'Carmen', 'Diana', 'Elena', 'Fernanda', 'Gabriela', 'Isabel',
        'Juana', 'Laura', 'Mar√≠a', 'Natalia', 'Olivia', 'Patricia', 'Rosa', 'Sof√≠a',
        'Teresa', 'Valentina', 'Ximena', 'Yolanda'
    ]
    
    SURNAMES = [
        'Garc√≠a', 'Rodr√≠guez', 'Gonz√°lez', 'Fern√°ndez', 'L√≥pez', 'Mart√≠nez', 'S√°nchez', 'P√©rez',
        'G√≥mez', 'Mart√≠n', 'Jim√©nez', 'Ruiz', 'Hern√°ndez', 'D√≠az', 'Moreno', 'Mu√±oz',
        '√Ålvarez', 'Romero', 'Alonso', 'Guti√©rrez'
    ]
    
    @classmethod
    def generate_random_person(cls, level: int) -> Person:
        """Genera una persona aleatoria"""
        gender = random.choice(['masculino', 'femenino'])
        
        if gender == 'masculino':
            first_name = random.choice(cls.MALE_NAMES)
        else:
            first_name = random.choice(cls.FEMALE_NAMES)
        
        surname = random.choice(cls.SURNAMES)
        name = f"{first_name} {surname}"
        
        # Rangos de edad por nivel (0 = generaci√≥n m√°s antigua)
        age_ranges = [
            (70, 90),  # Nivel 0: Bisabuelos
            (45, 70),  # Nivel 1: Abuelos
            (25, 50),  # Nivel 2: Padres
            (5, 30)    # Nivel 3: Hijos
        ]
        
        min_age, max_age = age_ranges[min(level, 3)]
        age = random.randint(min_age, max_age)
        
        return Person(name, age, gender, level)

class TreeGenerator:
    """Generador de √°rboles geneal√≥gicos"""
    
    @staticmethod
    def generate_family_tree(max_levels: int, max_nodes: int) -> Person:
        """Genera un √°rbol geneal√≥gico aleatorio asegurando todos los niveles y nodos"""
        root = PersonGenerator.generate_random_person(0)
        all_nodes = [root]
        node_count = 1
        
        # Asegurar que se generen todos los niveles
        for level in range(max_levels - 1):
            current_level_nodes = [node for node in all_nodes if node.level == level]
            
            # Si no hay nodos en el nivel actual, no podemos continuar
            if not current_level_nodes:
                break
            
            # Calcular cu√°ntos nodos necesitamos para este nivel
            remaining_nodes = max_nodes - node_count
            remaining_levels = max_levels - level - 1
            
            if remaining_nodes <= 0:
                break
            
            # Distribuir los nodos restantes entre los padres disponibles
            nodes_per_parent = max(1, remaining_nodes // len(current_level_nodes))
            extra_nodes = remaining_nodes % len(current_level_nodes)
            
            # Asegurar que cada padre tenga al menos un hijo si hay espacio
            for i, parent in enumerate(current_level_nodes):
                if node_count >= max_nodes:
                    break
                
                # Calcular cu√°ntos hijos debe tener este padre
                base_children = min(nodes_per_parent, remaining_nodes)
                extra_child = 1 if i < extra_nodes else 0
                children_count = base_children + extra_child
                
                # Limitar el n√∫mero de hijos por padre (m√°ximo 4)
                children_count = min(children_count, 4)
                
                # Si es el √∫ltimo nivel, asegurar que se usen todos los nodos restantes
                if level == max_levels - 2:  # √öltimo nivel de padres
                    remaining_space = max_nodes - node_count
                    children_count = min(children_count, remaining_space)
                
                # Generar los hijos
                for j in range(children_count):
                    if node_count >= max_nodes:
                        break
                    
                    child = PersonGenerator.generate_random_person(level + 1)
                    parent.add_child(child)
                    all_nodes.append(child)
                    node_count += 1
                    remaining_nodes -= 1
        
        # Si a√∫n no hemos alcanzado el n√∫mero m√°ximo de nodos y tenemos niveles disponibles,
        # agregar m√°s nodos a los padres existentes
        while node_count < max_nodes:
            # Buscar padres que puedan tener m√°s hijos
            potential_parents = [node for node in all_nodes 
                               if node.level < max_levels - 1 and len(node.children) < 4]
            
            if not potential_parents:
                break
            
            # Seleccionar un padre aleatorio y agregarle un hijo
            parent = random.choice(potential_parents)
            child = PersonGenerator.generate_random_person(parent.level + 1)
            parent.add_child(child)
            all_nodes.append(child)
            node_count += 1
        
        return root
    
    @staticmethod
    def get_all_nodes(root: Person) -> List[Person]:
        """Obtiene todos los nodos del √°rbol"""
        nodes = []
        queue = deque([root])
        
        while queue:
            current = queue.popleft()
            nodes.append(current)
            queue.extend(current.children)
        
        return nodes

class SearchAlgorithms:
    """Algoritmos de b√∫squeda en √°rboles"""
    
    @staticmethod
    def breadth_first_search(root: Person, target_name: str) -> SearchResult:
        """B√∫squeda en anchura (BFS)"""
        start_time = time.time()
        queue = deque([root])
        visited = set()
        visited_order = []
        visited_nodes = 0
        
        while queue:
            current = queue.popleft()
            visited_nodes += 1
            
            if current.id in visited:
                continue
                
            visited.add(current.id)
            visited_order.append(current)
            
            if target_name.lower() in current.name.lower():
                end_time = time.time()
                return SearchResult(
                    current, True, visited_nodes, 
                    (end_time - start_time) * 1000, visited_order
                )
            
            queue.extend(current.children)
        
        end_time = time.time()
        return SearchResult(
            None, False, visited_nodes, 
            (end_time - start_time) * 1000, visited_order
        )
    
    @staticmethod
    def depth_first_search(root: Person, target_name: str) -> SearchResult:
        """B√∫squeda en profundidad (DFS)"""
        start_time = time.time()
        visited = set()
        visited_order = []
        visited_nodes = 0
        
        def dfs_recursive(node: Person) -> Optional[Person]:
            nonlocal visited_nodes
            
            if node.id in visited:
                return None
            
            visited.add(node.id)
            visited_nodes += 1
            visited_order.append(node)
            
            if target_name.lower() in node.name.lower():
                return node
            
            for child in node.children:
                result = dfs_recursive(child)
                if result:
                    return result
            
            return None
        
        result = dfs_recursive(root)
        end_time = time.time()
        
        return SearchResult(
            result, result is not None, visited_nodes,
            (end_time - start_time) * 1000, visited_order
        )

class TreeVisualizer:
    """Visualizador de √°rboles geneal√≥gicos"""
    
    @staticmethod
    def print_complete_tree(root: Person, prefix: str = "", is_last: bool = True):
        """Imprime el √°rbol geneal√≥gico completo"""
        connector = "‚îî‚îÄ‚îÄ " if is_last else "‚îú‚îÄ‚îÄ "
        print(f"{prefix}{connector}{root}")
        
        if root.children:
            for i, child in enumerate(root.children):
                is_last_child = i == len(root.children) - 1
                extension = "    " if is_last else "‚îÇ   "
                TreeVisualizer.print_complete_tree(
                    child, prefix + extension, is_last_child
                )
    
    @staticmethod
    def print_search_tree(visited_nodes: List[Person], found_person: Optional[Person], 
                         algorithm_name: str):
        """Imprime el √°rbol de b√∫squeda mostrando solo nodos visitados"""
        print(f"\n{'='*60}")
        print(f"√ÅRBOL DE B√öSQUEDA {algorithm_name.upper()}")
        print(f"{'='*60}")
        
        if not visited_nodes:
            print("No se visitaron nodos durante la b√∫squeda.")
            return
        
        # Crear un mapeo de nodos visitados
        visited_set = {node.id for node in visited_nodes}
        visit_order = {node.id: i + 1 for i, node in enumerate(visited_nodes)}
        
        def print_visited_tree(node: Person, prefix: str = "", is_last: bool = True, 
                              parent_visited: bool = True):
            if node.id not in visited_set:
                return
            
            connector = "‚îî‚îÄ‚îÄ " if is_last else "‚îú‚îÄ‚îÄ "
            order = visit_order.get(node.id, 0)
            found_marker = " *** ENCONTRADO ***" if found_person and node.id == found_person.id else ""
            
            print(f"{prefix}{connector}[{order:2d}] {node}{found_marker}")
            
            # Solo mostrar hijos que fueron visitados
            visited_children = [child for child in node.children if child.id in visited_set]
            
            if visited_children:
                for i, child in enumerate(visited_children):
                    is_last_child = i == len(visited_children) - 1
                    extension = "    " if is_last else "‚îÇ   "
                    print_visited_tree(
                        child, prefix + extension, is_last_child, True
                    )
        
        # Encontrar la ra√≠z del √°rbol de b√∫squeda
        root_node = visited_nodes[0]
        print_visited_tree(root_node)
        
        print(f"\nLeyenda: [XX] = Orden de visita durante {algorithm_name}")
        if found_person:
            print(f"*** ENCONTRADO *** = Persona encontrada: {found_person.name}")

class GenealogyApp:
    """Aplicaci√≥n principal del √°rbol geneal√≥gico"""
    
    def __init__(self):
        self.family_tree: Optional[Person] = None
        self.all_persons: List[Person] = []
    
    def print_header(self):
        """Imprime el encabezado de la aplicaci√≥n"""
        print("\n" + "="*80)
        print("üå≥ APLICACI√ìN DE √ÅRBOL GENEAL√ìGICO CON B√öSQUEDA üå≥")
        print("="*80)
        print("Genera √°rboles familiares aleatorios y busca usando algoritmos BFS y DFS")
        print("="*80)
    
    def get_tree_configuration(self) -> Tuple[int, int]:
        """Solicita la configuraci√≥n del √°rbol al usuario"""
        print("\nüìã CONFIGURACI√ìN DEL √ÅRBOL GENEAL√ìGICO")
        print("-" * 50)
        
        while True:
            try:
                max_levels = int(input("Ingrese el n√∫mero m√°ximo de niveles (1-4): "))
                if 1 <= max_levels <= 4:
                    break
                else:
                    print("‚ùå Por favor, ingrese un n√∫mero entre 1 y 4.")
            except ValueError:
                print("‚ùå Por favor, ingrese un n√∫mero v√°lido.")
        
        while True:
            try:
                max_nodes = int(input("Ingrese el n√∫mero m√°ximo de nodos (1-25): "))
                if 1 <= max_nodes <= 25:
                    break
                else:
                    print("‚ùå Por favor, ingrese un n√∫mero entre 1 y 25.")
            except ValueError:
                print("‚ùå Por favor, ingrese un n√∫mero v√°lido.")
        
        return max_levels, max_nodes
    
    def generate_tree(self, max_levels: int, max_nodes: int):
        """Genera el √°rbol geneal√≥gico"""
        print(f"\nüîÑ Generando √°rbol geneal√≥gico con {max_levels} niveles y m√°ximo {max_nodes} nodos...")
        
        self.family_tree = TreeGenerator.generate_family_tree(max_levels, max_nodes)
        self.all_persons = TreeGenerator.get_all_nodes(self.family_tree)
        
        # Verificar que se generaron todos los niveles solicitados
        levels_generated = set(person.level for person in self.all_persons)
        max_level_generated = max(levels_generated) if levels_generated else 0
        
        print(f"‚úÖ √Årbol generado exitosamente:")
        print(f"   üìä Total de personas: {len(self.all_persons)}")
        print(f"   üìà Niveles generados: {max_level_generated + 1} (0-{max_level_generated})")
        print(f"   üéØ Objetivo: {max_levels} niveles, {max_nodes} nodos m√°ximo")
        
        # Mostrar distribuci√≥n por niveles
        level_counts = {}
        for person in self.all_persons:
            level_counts[person.level] = level_counts.get(person.level, 0) + 1
        
        print(f"   üìã Distribuci√≥n por niveles:")
        for level in sorted(level_counts.keys()):
            level_names = ["Ancestros", "Abuelos", "Padres", "Hijos"]
            level_name = level_names[min(level, 3)]
            print(f"      Nivel {level} ({level_name}): {level_counts[level]} personas")
    
    def display_complete_tree(self):
        """Muestra el √°rbol geneal√≥gico completo"""
        if not self.family_tree:
            print("‚ùå No hay √°rbol geneal√≥gico generado.")
            return
        
        print(f"\nüå≥ √ÅRBOL GENEAL√ìGICO COMPLETO ({len(self.all_persons)} miembros)")
        print("=" * 60)
        TreeVisualizer.print_complete_tree(self.family_tree)
    
    def show_available_persons(self):
        """Muestra las personas disponibles para b√∫squeda"""
        if not self.all_persons:
            return
        
        print(f"\nüë• PERSONAS DISPONIBLES EN EL √ÅRBOL:")
        print("-" * 50)
        for i, person in enumerate(self.all_persons, 1):
            print(f"{i:2d}. {person}")
    
    def get_search_term(self) -> str:
        """Solicita el t√©rmino de b√∫squeda al usuario"""
        print(f"\nüîç B√öSQUEDA DE PERSONA")
        print("-" * 30)
        
        while True:
            search_term = input("Ingrese el nombre de la persona a buscar: ").strip()
            if search_term:
                return search_term
            else:
                print("‚ùå Por favor, ingrese un nombre v√°lido.")
    
    def perform_searches(self, search_term: str):
        """Realiza las b√∫squedas BFS y DFS"""
        if not self.family_tree:
            print("‚ùå No hay √°rbol geneal√≥gico generado.")
            return
        
        print(f"\nüîç Buscando '{search_term}' en el √°rbol geneal√≥gico...")
        print("=" * 60)
        
        # B√∫squeda BFS
        print("\nüîÑ Ejecutando B√∫squeda en Anchura (BFS)...")
        bfs_result = SearchAlgorithms.breadth_first_search(self.family_tree, search_term)
        
        # B√∫squeda DFS
        print("üîÑ Ejecutando B√∫squeda en Profundidad (DFS)...")
        dfs_result = SearchAlgorithms.depth_first_search(self.family_tree, search_term)
        
        # Mostrar resultados
        self.display_search_results(bfs_result, dfs_result, search_term)
        
        # Mostrar √°rboles de b√∫squeda
        TreeVisualizer.print_search_tree(bfs_result.visited_order, bfs_result.person, "BFS")
        TreeVisualizer.print_search_tree(dfs_result.visited_order, dfs_result.person, "DFS")
        
        # Comparaci√≥n de rendimiento
        self.display_performance_comparison(bfs_result, dfs_result)
    
    def display_search_results(self, bfs_result: SearchResult, dfs_result: SearchResult, 
                             search_term: str):
        """Muestra los resultados de las b√∫squedas"""
        print(f"\nüìä RESULTADOS DE B√öSQUEDA PARA: '{search_term}'")
        print("=" * 60)
        
        # Resultado BFS
        print(f"\nüîµ B√öSQUEDA EN ANCHURA (BFS):")
        print("-" * 40)
        if bfs_result.found:
            print(f"‚úÖ ENCONTRADO: {bfs_result.person}")
        else:
            print("‚ùå PERSONA NO ENCONTRADA")
        
        print(f"üìà Nodos visitados: {bfs_result.visited_nodes}")
        print(f"‚è±Ô∏è  Tiempo de ejecuci√≥n: {bfs_result.execution_time:.4f} ms")
        
        # Resultado DFS
        print(f"\nüü¢ B√öSQUEDA EN PROFUNDIDAD (DFS):")
        print("-" * 40)
        if dfs_result.found:
            print(f"‚úÖ ENCONTRADO: {dfs_result.person}")
        else:
            print("‚ùå PERSONA NO ENCONTRADA")
        
        print(f"üìà Nodos visitados: {dfs_result.visited_nodes}")
        print(f"‚è±Ô∏è  Tiempo de ejecuci√≥n: {dfs_result.execution_time:.4f} ms")
    
    def display_performance_comparison(self, bfs_result: SearchResult, dfs_result: SearchResult):
        """Muestra la comparaci√≥n de rendimiento"""
        print(f"\n‚ö° AN√ÅLISIS COMPARATIVO DE RENDIMIENTO")
        print("=" * 60)
        
        print(f"üìä Eficiencia en nodos:")
        if bfs_result.visited_nodes < dfs_result.visited_nodes:
            print(f"   üèÜ BFS fue m√°s eficiente ({bfs_result.visited_nodes} vs {dfs_result.visited_nodes} nodos)")
        elif dfs_result.visited_nodes < bfs_result.visited_nodes:
            print(f"   üèÜ DFS fue m√°s eficiente ({dfs_result.visited_nodes} vs {bfs_result.visited_nodes} nodos)")
        else:
            print(f"   ü§ù Ambos algoritmos visitaron la misma cantidad de nodos ({bfs_result.visited_nodes})")
        
        print(f"\n‚è±Ô∏è  Velocidad de ejecuci√≥n:")
        if bfs_result.execution_time < dfs_result.execution_time:
            print(f"   üèÜ BFS fue m√°s r√°pido ({bfs_result.execution_time:.4f} vs {dfs_result.execution_time:.4f} ms)")
        elif dfs_result.execution_time < bfs_result.execution_time:
            print(f"   üèÜ DFS fue m√°s r√°pido ({dfs_result.execution_time:.4f} vs {bfs_result.execution_time:.4f} ms)")
        else:
            print(f"   ü§ù Ambos algoritmos tuvieron tiempos similares")
        
        print(f"\nüß† Caracter√≠sticas de los algoritmos:")
        print(f"   ‚Ä¢ BFS: Explora nivel por nivel (anchura primero)")
        print(f"   ‚Ä¢ DFS: Explora rama por rama hasta el fondo (profundidad primero)")
    
    def run(self):
        """Ejecuta la aplicaci√≥n principal"""
        self.print_header()
        
        # Configuraci√≥n del √°rbol
        max_levels, max_nodes = self.get_tree_configuration()
        
        # Generar √°rbol
        self.generate_tree(max_levels, max_nodes)
        
        # Mostrar √°rbol completo
        self.display_complete_tree()
        
        # Mostrar personas disponibles
        self.show_available_persons()
        
        # B√∫squeda
        search_term = self.get_search_term()
        
        # Realizar b√∫squedas
        self.perform_searches(search_term)
        
        print(f"\nüéâ ¬°Aplicaci√≥n completada exitosamente!")
        print("=" * 80)

def main():
    """Funci√≥n principal"""
    try:
        app = GenealogyApp()
        app.run()
    except KeyboardInterrupt:
        print("\n\nüëã Aplicaci√≥n interrumpida por el usuario. ¬°Hasta luego!")
    except Exception as e:
        print(f"\n‚ùå Error inesperado: {e}")

if __name__ == "__main__":
    main()</pre>
        </div>
        <textarea id="output"></textarea>
    </div>
    <script src="data/js/script.js" tpye="text/javascript"></script>
</body>

</html>